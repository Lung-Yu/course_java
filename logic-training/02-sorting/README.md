# 排序演算法 (Sorting Algorithms)

排序演算法是將一組資料依照特定順序（例如由小到大或由大到小）重新排列的演算法。排序是電腦科學中最基本也最重要的操作之一。本章節介紹三種基礎的排序方法：泡泡排序、選擇排序與插入排序。

---

## 1. 泡泡排序 (Bubble Sort)

> `BubbleSort.java`: 泡泡排序

泡泡排序是一種簡單的排序演算法。它會重複地走訪要排序的陣列，兩兩比較相鄰的元素，如果順序錯誤就進行交換。這個過程會重複進行，直到沒有任何一對元素需要交換為止。

### 概念

-   從陣列的第一個元素開始，比較它與下一個元素。
-   如果當前元素比下一個元素大，就交換它們。
-   對陣列中的每一對相鄰元素重複此步驟，從頭到尾。這趟走訪結束後，最大的元素會被「冒泡」到陣列的末端。
-   重複上述步驟，但每次都少比較最後一個已經就位的元素，直到整個陣列排序完成。

### 特性

-   **穩定性**：穩定 (Stable)。相同值的元素在排序後相對位置不變。
-   **空間**：原地 (In-place) 排序，僅需常數級別的額外空間。
-   **效率**：效率較低，不適合用於大規模資料。

### 效率 (時間複雜度)

-   **最壞與平均情況**：`O(n²)`。當陣列為逆序時。
-   **最佳情況**：`O(n)`。當陣列已經排序完成時，只需走訪一次即可確認 (需加入優化標記)。

---

## 2. 選擇排序 (Selection Sort)

選擇排序的運作方式是，每一次從待排序的資料元素中，選出最小（或最大）的一個元素，存放到序列的起始位置，然後再從剩餘未排序元素中繼續尋找最小（大）元素，然後放到已排序序列的末尾。

### 概念

1.  在未排序的序列中找到最小的元素。
2.  將該最小元素與未排序序列的第一個元素交換位置。
3.  將第一個元素視為已排序序列的一部分。
4.  重複步驟 1-3，直到所有元素都排序完畢。

### 特性

-   **穩定性**：不穩定 (Unstable)。在交換過程中，可能改變相同值的元素的相對位置。
-   **空間**：原地 (In-place) 排序。
-   **交換次數**：交換次數少 (最多 n-1 次)，對於寫入成本高的儲存媒體有利。

### 效率 (時間複雜度)

-   **最壞、最佳與平均情況**：`O(n²)`。無論輸入資料的狀態如何，都需要完整的兩層迴圈來找到並放置每一個元素。

---

## 3. 插入排序 (Insertion Sort)

> `InsertionSort.java`: 插入排序

插入排序的原理是，將一個資料插入到已經排好序的有序資料中，從而得到一個新的、個數加一的有序資料。

### 概念

-   將陣列的第一個元素視為一個已排序的序列。
-   依序從第二個元素開始，將其取出。
-   將取出的元素與已排序序列中的元素從後向前比較。
-   如果已排序的元素大於取出的元素，則將該元素向後移動。
-   重複此過程，直到找到一個小於或等於取出元素的位置，將取出元素插入該位置。
-   重複步驟 2-5，直到所有元素都被插入到正確的位置。

### 特性

-   **穩定性**：穩定 (Stable)。
-   **空間**：原地 (In-place) 排序。
-   **適應性**：對於「部分有序」或「資料量較小」的陣列，效率非常高。

### 效率 (時間複雜度)

-   **最壞與平均情況**：`O(n²)`。當陣列為逆序時。
-   **最佳情況**：`O(n)`。當陣列已經排序完成時，每次只需比較一次即可。
