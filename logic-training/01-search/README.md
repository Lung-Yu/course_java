# 搜尋演算法 (Searching Algorithms)

搜尋演算法是在資料集合中尋找特定項目的基本演算法。本章節介紹兩種基礎的搜尋方法：線性搜尋與二元搜尋。

---

## 1. 線性搜尋 (Linear Search)

線性搜尋是最直觀的搜尋方法。它會從資料集合的第一個元素開始，逐一比對，直到找到目標元素或遍歷完所有元素為止。

### 概念

-   **遍歷**：依序檢查陣列中的每一個元素。
-   **比對**：將目前檢查的元素與目標值進行比較。
-   **回傳**：如果找到相符的元素，立即回傳其索引；若走訪完所有元素都未找到，則回傳一個特殊值 (例如 -1)，表示目標不存在。

### 特性

-   **適用性**：適用於任何類型的陣列，無論陣列是否有序。
-   **簡單性**：演算法邏輯簡單，易於實作。

### 效率 (時間複雜度)

-   **最壞情況 (Worst Case)**：`O(n)`。當目標元素在陣列的最後一個位置，或目標元素不存在時，需要遍歷整個陣列。
-   **最佳情況 (Best Case)**：`O(1)`。當目標元素在陣列的第一個位置時，僅需比��一次。
-   **平均情況 (Average Case)**：`O(n)`。平均需要檢查 n/2 個元素。

---

## 2. 二元搜尋 (Binary Search)

二元搜尋是一種高效的搜尋演算法，但它有一個重要的 **前提：陣列必須是已排序的**。

它透過反覆將搜尋範圍切成兩半來運作，每次都排除掉不可能包含目標的那一半。

### 概念

1.  **設定指標**：設定 `left` 和 `right` 兩個指標，分別指向陣列的頭和尾。
2.  **計算中間值**：計算中間索引 `mid`。
3.  **比對**：
    -   如果 `arr[mid]` 等於目標值，搜尋成功。
    -   如果 `arr[mid]` 小於目標值，表示目標可能在右半邊，因此將 `left` 指標移至 `mid + 1`。
    -   如果 `arr[mid]` 大於目標值，表示目標可能在左半邊，因此將 `right` 指標移至 `mid - 1`。
4.  **重複**：重複步驟 2 和 3，直到 `left` 指標大於 `right` 指標，此時表示陣列中不存在目標值。

### 特性

-   **高效率**：相較於線性搜尋，搜尋速度非常快。
-   **前提條件**：**必須** 作用於已排序的資料。如果資料未排序，搜尋結果將是錯誤的。

### 效率 (時間複雜度)

-   **最壞情況 (Worst Case)**：`O(log n)`。每次搜尋都將範圍縮小一半，因此執行次數與資料規模的對數成正比。
-   **最佳情況 (Best Case)**：`O(1)`。當目標元素恰好在陣列的中間時。
-   **平均情況 (Average Case)**：`O(log n)`。
